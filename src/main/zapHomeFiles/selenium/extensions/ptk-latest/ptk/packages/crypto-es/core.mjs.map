{"version":3,"file":"core.mjs","names":["crypto: Crypto | undefined","randomWordArray: (nBytes: number) => WordArray","words: number[]","rcache: number | undefined","uint8Array: Uint8Array","Hex: Encoder","hexChars: string[]","Latin1: Encoder","latin1Chars: string[]","Utf8: Encoder","m_data: WordArray","processedWords: number[] | undefined","_key: WordArray"],"sources":["../src/core.ts"],"sourcesContent":["/* eslint-disable no-use-before-define */\n\nimport type { X64WordArray } from './x64-core';\n\n/**\n * Encoder interface for encoding strategies\n */\nexport interface Encoder {\n  /**\n   * Converts a word array to a string representation\n   * @param wordArray - The word array to stringify\n   * @returns The string representation\n   */\n  stringify(wordArray: WordArray): string;\n  \n  /**\n   * Converts a string to a word array\n   * @param str - The string to parse\n   * @returns The word array representation\n   */\n  parse(str: string): WordArray;\n}\n\n/**\n * Configuration options for hashers\n */\nexport interface HasherCfg {\n  /** Output length for SHA3 */\n  outputLength?: number;\n}\n\n/**\n * Type definition for hash functions\n */\nexport type HashFn = (message: WordArray | string, cfg?: HasherCfg) => WordArray;\n\n/**\n * Type definition for HMAC hash functions\n */\nexport type HMACHashFn = (message: WordArray | string, key: WordArray | string) => WordArray;\n\n/**\n * Type for supported typed arrays\n */\ntype TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | \n                  Int16Array | Uint16Array | \n                  Int32Array | Uint32Array |\n                  Float32Array | Float64Array;\n\n/**\n * Type for word array input\n */\ntype WordArrayInput = number[] | ArrayBuffer | TypedArray;\n\n/**\n * Get global crypto object across different environments\n */\ndeclare const global: any;\nconst crypto: Crypto | undefined =\n  (typeof globalThis !== 'undefined' ? globalThis : void 0)?.crypto ||\n  (typeof global !== 'undefined' ? (global as any) : void 0)?.crypto ||\n  (typeof window !== 'undefined' ? window : void 0)?.crypto ||\n  (typeof self !== 'undefined' ? self : void 0)?.crypto ||\n  (typeof frames !== 'undefined' ? (frames as any) : void 0)?.[0]?.crypto;\n\n/**\n * Random word array generator function\n */\nlet randomWordArray: (nBytes: number) => WordArray;\n\nif (crypto) {\n  randomWordArray = (nBytes: number): WordArray => {\n    const words: number[] = [];\n\n    for (let i = 0; i < nBytes; i += 4) {\n      words.push(crypto.getRandomValues(new Uint32Array(1))[0]);\n    }\n\n    return new WordArray(words, nBytes);\n  };\n} else {\n  // Because there is no global crypto property in this context, cryptographically unsafe Math.random() is used.\n  randomWordArray = (nBytes: number): WordArray => {\n    const words: number[] = [];\n  \n    const r = (m_w: number): () => number => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n  \n      return (): number => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n  \n    let rcache: number | undefined;\n    for (let i = 0; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n  \n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n  \n    return new WordArray(words, nBytes);\n  };\n}\n\n/**\n * Base class for inheritance.\n * Provides basic object-oriented programming utilities.\n */\nexport class Base {\n  /**\n   * Creates a new instance of this class with the provided arguments.\n   * This is a factory method that provides an alternative to using 'new'.\n   * \n   * @param args - Arguments to pass to the constructor\n   * @returns A new instance of this class\n   * @static\n   * @example\n   * ```javascript\n   * const instance = MyType.create(arg1, arg2);\n   * ```\n   */\n  static create<T extends Base>(this: new (...args: any[]) => T, ...args: any[]): T {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties from the provided object into this instance.\n   * Performs a shallow merge of properties.\n   * \n   * @param properties - The properties to mix in\n   * @returns This instance for method chaining\n   * @example\n   * ```javascript\n   * instance.mixIn({ field: 'value', another: 123 });\n   * ```\n   */\n  mixIn(properties: Record<string, unknown>): this {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a deep copy of this object.\n   * \n   * @returns A clone of this instance\n   * @example\n   * ```javascript\n   * const clone = instance.clone();\n   * ```\n   */\n  clone(): this {\n    const clone = new (this.constructor as new () => this)();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n * This is the core data structure used throughout the library for representing binary data.\n * \n * @property words - The array of 32-bit words\n * @property sigBytes - The number of significant bytes in this word array\n */\nexport class WordArray extends Base {\n  /** The array of 32-bit words */\n  words!: number[];\n  \n  /** The number of significant bytes in this word array */\n  sigBytes!: number;\n\n  /**\n   * Initializes a newly created word array.\n   * Can accept various input formats including regular arrays, typed arrays, and ArrayBuffers.\n   * \n   * @param words - An array of 32-bit words, typed array, or ArrayBuffer\n   * @param sigBytes - The number of significant bytes in the words (defaults to words.length * 4)\n   * @example\n   * ```javascript\n   * const wordArray = new WordArray();\n   * const wordArray = new WordArray([0x00010203, 0x04050607]);\n   * const wordArray = new WordArray([0x00010203, 0x04050607], 6);\n   * const wordArray = new WordArray(new Uint8Array([1, 2, 3, 4]));\n   * ```\n   */\n  constructor(words: WordArrayInput = [], sigBytes?: number) {\n    super();\n\n    // Handle ArrayBuffer input\n    if (words instanceof ArrayBuffer) {\n      const typedArray = new Uint8Array(words);\n      this._initFromUint8Array(typedArray);\n      return;\n    }\n\n    // Handle typed array input\n    if (ArrayBuffer.isView(words)) {\n      let uint8Array: Uint8Array;\n      \n      if (words instanceof Uint8Array) {\n        uint8Array = words;\n      } else {\n        // Convert other typed arrays to Uint8Array\n        uint8Array = new Uint8Array(\n          words.buffer, \n          words.byteOffset, \n          words.byteLength\n        );\n      }\n      \n      this._initFromUint8Array(uint8Array);\n      return;\n    }\n\n    // Handle regular array input\n    this.words = words as number[];\n    this.sigBytes = sigBytes !== undefined ? sigBytes : this.words.length * 4;\n  }\n\n  /**\n   * Initialize from Uint8Array\n   * @private\n   */\n  private _initFromUint8Array(typedArray: Uint8Array): void {\n    const typedArrayByteLength = typedArray.byteLength;\n    const words: number[] = [];\n    \n    for (let i = 0; i < typedArrayByteLength; i += 1) {\n      words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n    }\n\n    this.words = words;\n    this.sigBytes = typedArrayByteLength;\n  }\n\n  /**\n   * Creates a word array filled with cryptographically strong random bytes.\n   * Uses Web Crypto API if available, falls back to Math.random() if not.\n   * \n   * @param nBytes - The number of random bytes to generate\n   * @returns The random word array\n   * @static\n   * @example\n   * ```javascript\n   * const randomBytes = WordArray.random(16); // Generate 16 random bytes\n   * ```\n   */\n  static random = randomWordArray;\n\n  /**\n   * Converts this word array to a string using the specified encoding.\n   * \n   * @param encoder - The encoding strategy to use (defaults to Hex)\n   * @returns The stringified word array\n   * @example\n   * ```javascript\n   * const hexString = wordArray.toString();\n   * const base64String = wordArray.toString(Base64);\n   * const utf8String = wordArray.toString(Utf8);\n   * ```\n   */\n  toString(encoder: Encoder = Hex): string {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   * Modifies this word array in place.\n   * \n   * @param wordArray - The word array to append\n   * @returns This word array for method chaining\n   * @example\n   * ```javascript\n   * wordArray1.concat(wordArray2);\n   * const combined = wordArray1.concat(wordArray2).concat(wordArray3);\n   * ```\n   */\n  concat(wordArray: WordArray): this {\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time for unaligned data\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time for aligned data\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits from the end of the word array.\n   * This ensures the word array only contains the exact number of significant bytes.\n   * \n   * @example\n   * ```javascript\n   * wordArray.clamp();\n   * ```\n   */\n  clamp(): void {\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   * \n   * @returns The cloned word array\n   * @example\n   * ```javascript\n   * const clone = wordArray.clone();\n   * ```\n   */\n  clone(): this {\n    const clone = super.clone();\n    clone.words = this.words.slice(0);\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n * Converts between word arrays and hexadecimal strings.\n */\nexport const Hex: Encoder = {\n  /**\n   * Converts a word array to a hex string.\n   * \n   * @param wordArray - The word array to convert\n   * @returns The hex string representation\n   * @example\n   * ```javascript\n   * const hexString = Hex.stringify(wordArray);\n   * ```\n   */\n  stringify(wordArray: WordArray): string {\n    const { words, sigBytes } = wordArray;\n    const hexChars: string[] = [];\n    \n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   * \n   * @param hexStr - The hex string to parse\n   * @returns The word array representation\n   * @example\n   * ```javascript\n   * const wordArray = Hex.parse('48656c6c6f');\n   * ```\n   */\n  parse(hexStr: string): WordArray {\n    const hexStrLength = hexStr.length;\n    const words: number[] = [];\n    \n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  }\n};\n\n/**\n * Latin1 encoding strategy.\n * Converts between word arrays and Latin-1 (ISO-8859-1) strings.\n */\nexport const Latin1: Encoder = {\n  /**\n   * Converts a word array to a Latin1 string.\n   * \n   * @param wordArray - The word array to convert\n   * @returns The Latin1 string representation\n   * @example\n   * ```javascript\n   * const latin1String = Latin1.stringify(wordArray);\n   * ```\n   */\n  stringify(wordArray: WordArray): string {\n    const { words, sigBytes } = wordArray;\n    const latin1Chars: string[] = [];\n    \n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   * \n   * @param latin1Str - The Latin1 string to parse\n   * @returns The word array representation\n   * @example\n   * ```javascript\n   * const wordArray = Latin1.parse('Hello');\n   * ```\n   */\n  parse(latin1Str: string): WordArray {\n    const latin1StrLength = latin1Str.length;\n    const words: number[] = [];\n    \n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  }\n};\n\n/**\n * UTF-8 encoding strategy.\n * Converts between word arrays and UTF-8 strings.\n */\nexport const Utf8: Encoder = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   * \n   * @param wordArray - The word array to convert\n   * @returns The UTF-8 string representation\n   * @throws Error if the data is malformed UTF-8\n   * @example\n   * ```javascript\n   * const utf8String = Utf8.stringify(wordArray);\n   * ```\n   */\n  stringify(wordArray: WordArray): string {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   * \n   * @param utf8Str - The UTF-8 string to parse\n   * @returns The word array representation\n   * @example\n   * ```javascript\n   * const wordArray = Utf8.parse('Hello, 世界');\n   * ```\n   */\n  parse(utf8Str: string): WordArray {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\n\n/**\n * Abstract buffered block algorithm template.\n * Provides a base implementation for algorithms that process data in fixed-size blocks.\n * \n * @property _minBufferSize - The number of blocks that should be kept unprocessed in the buffer\n */\nexport abstract class BufferedBlockAlgorithm extends Base {\n  /** The number of blocks that should be kept unprocessed in the buffer */\n  protected _minBufferSize: number = 0;\n  \n  /** The data buffer */\n  protected _data!: WordArray;\n  \n  /** The number of bytes in the data buffer */\n  protected _nDataBytes!: number;\n  \n  /** The block size in 32-bit words */\n  abstract blockSize: number;\n\n  constructor() {\n    super();\n    // Don't call reset() here - let subclasses do it after they've initialized their properties\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   * \n   * @example\n   * ```javascript\n   * bufferedBlockAlgorithm.reset();\n   * ```\n   */\n  reset(): void {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   * \n   * @param data - The data to append (strings are converted to WordArray using UTF-8)\n   * @example\n   * ```javascript\n   * bufferedBlockAlgorithm._append('data');\n   * bufferedBlockAlgorithm._append(wordArray);\n   * ```\n   */\n  protected _append(data: WordArray | string): void {\n    let m_data: WordArray;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof data === 'string') {\n      m_data = Utf8.parse(data);\n    } else {\n      m_data = data;\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   * This method invokes _doProcessBlock(dataWords, offset), which must be implemented by a concrete subtype.\n   * \n   * @param doFlush - Whether all blocks and partial blocks should be processed\n   * @returns The processed data\n   * @example\n   * ```javascript\n   * const processedData = bufferedBlockAlgorithm._process();\n   * const processedData = bufferedBlockAlgorithm._process(true); // Flush\n   * ```\n   */\n  protected _process(doFlush?: boolean): WordArray {\n    let processedWords: number[] | undefined;\n\n    const data = this._data;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = this.blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * this.blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords || [], nBytesReady);\n  }\n\n  /**\n   * Process a single block of data.\n   * Must be implemented by concrete subclasses.\n   * \n   * @param dataWords - The data words array\n   * @param offset - The offset in the data words array\n   */\n  protected abstract _doProcessBlock(dataWords: number[], offset: number): void;\n\n  /**\n   * Creates a copy of this object.\n   * \n   * @returns The clone\n   * @example\n   * ```javascript\n   * const clone = bufferedBlockAlgorithm.clone();\n   * ```\n   */\n  clone(): this {\n    const clone = super.clone();\n    clone._data = this._data.clone();\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n * Base class for all hash algorithm implementations.\n * \n * @property blockSize - The number of 32-bit words this hasher operates on (default: 16 = 512 bits)\n */\nexport abstract class Hasher extends BufferedBlockAlgorithm {\n  /** The number of 32-bit words this hasher operates on */\n  blockSize: number = 512 / 32;\n  \n  /** Configuration options */\n  cfg: HasherCfg;\n  \n  /** The hash result */\n  protected _hash!: WordArray | X64WordArray;\n\n  /**\n   * Initializes a newly created hasher.\n   * \n   * @param cfg - Configuration options\n   */\n  constructor(cfg?: HasherCfg) {\n    super();\n    this.cfg = Object.assign({}, cfg);\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   * \n   * @param SubHasher - The hasher class to create a helper for\n   * @returns The shortcut function\n   * @static\n   * @example\n   * ```javascript\n   * const SHA256 = Hasher._createHelper(SHA256Algo);\n   * ```\n   */\n  static _createHelper<T extends Hasher>(SubHasher: new (cfg?: HasherCfg) => T): HashFn {\n    return (message: WordArray | string, cfg?: HasherCfg): WordArray => {\n      return new SubHasher(cfg).finalize(message);\n    };\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   * \n   * @param SubHasher - The hasher class to use in this HMAC helper\n   * @returns The shortcut function\n   * @static\n   * @example\n   * ```javascript\n   * const HmacSHA256 = Hasher._createHmacHelper(SHA256Algo);\n   * ```\n   */\n  static _createHmacHelper<T extends Hasher>(SubHasher: new (cfg?: HasherCfg) => T): HMACHashFn {\n    return (message: WordArray | string, key: WordArray | string): WordArray => {\n      return new HMAC(SubHasher, key).finalize(message);\n    };\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   * \n   * @example\n   * ```javascript\n   * hasher.reset();\n   * ```\n   */\n  reset(): void {\n    super.reset();\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   * \n   * @param messageUpdate - The message to append\n   * @returns This hasher instance for method chaining\n   * @example\n   * ```javascript\n   * hasher.update('message');\n   * hasher.update(wordArray);\n   * ```\n   */\n  update(messageUpdate: WordArray | string): this {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   * \n   * @param messageUpdate - An optional final message update\n   * @returns The computed hash\n   * @example\n   * ```javascript\n   * const hash = hasher.finalize();\n   * const hash = hasher.finalize('message');\n   * const hash = hasher.finalize(wordArray);\n   * ```\n   */\n  finalize(messageUpdate?: WordArray | string): WordArray {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    const hash = this._doFinalize();\n    return hash;\n  }\n\n  /**\n   * Resets the hasher to its initial state.\n   * Must be implemented by concrete subclasses.\n   */\n  protected abstract _doReset(): void;\n\n  /**\n   * Finalizes the hash computation.\n   * Must be implemented by concrete subclasses.\n   */\n  protected abstract _doFinalize(): WordArray;\n}\n\n/**\n * Base class for 32-bit hash algorithms.\n * Hash algorithms that operate on 32-bit words should extend this class.\n */\nexport abstract class Hasher32 extends Hasher {\n  /** The hash result (always WordArray for 32-bit hashers) */\n  declare protected _hash: WordArray;\n\n  /**\n   * Finalizes the hash computation.\n   * Must be implemented by concrete subclasses.\n   */\n  protected abstract _doFinalize(): WordArray;\n}\n\n/**\n * Base class for 64-bit hash algorithms.\n * Hash algorithms that operate on 64-bit words should extend this class.\n */\nexport abstract class Hasher64 extends Hasher {\n  /** The hash result (always X64WordArray for 64-bit hashers) */\n  declare protected _hash: X64WordArray;\n\n  /**\n   * Finalizes the hash computation.\n   * Must be implemented by concrete subclasses.\n   * @returns The hash result as a 32-bit WordArray\n   */\n  protected abstract _doFinalize(): WordArray;\n}\n\n/**\n * HMAC (Hash-based Message Authentication Code) algorithm.\n * Provides message authentication using a cryptographic hash function and a secret key.\n */\nexport class HMAC extends Base {\n  /** The inner hasher instance */\n  private _hasher: Hasher;\n  \n  /** The outer key */\n  private _oKey: WordArray;\n  \n  /** The inner key */\n  private _iKey: WordArray;\n\n  /**\n   * Initializes a newly created HMAC.\n   * \n   * @param SubHasher - The hash algorithm class to use\n   * @param key - The secret key\n   * @example\n   * ```javascript\n   * const hmac = new HMAC(SHA256Algo, 'secret key');\n   * ```\n   */\n  constructor(SubHasher: new (cfg?: HasherCfg) => Hasher, key: WordArray | string) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key: WordArray;\n    if (typeof key === 'string') {\n      _key = Utf8.parse(key);\n    } else {\n      _key = key;\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(_key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Factory method to create an HMAC instance.\n   * \n   * @param SubHasher - The hash algorithm class to use\n   * @param key - The secret key\n   * @returns A new HMAC instance\n   * @static\n   * @example\n   * ```javascript\n   * const hmac = HMAC.create(SHA256Algo, key);\n   * ```\n   */\n  static create(SubHasher: new (cfg?: HasherCfg) => Hasher, key: WordArray | string): HMAC;\n  static create<T extends HMAC>(this: new (...args: any[]) => T, ...args: any[]): T;\n  static create(...args: any[]): any {\n    const [SubHasher, key] = args;\n    return new HMAC(SubHasher, key);\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   * \n   * @example\n   * ```javascript\n   * hmac.reset();\n   * ```\n   */\n  reset(): void {\n    const hasher = this._hasher;\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   * \n   * @param messageUpdate - The message to append\n   * @returns This HMAC instance for method chaining\n   * @example\n   * ```javascript\n   * hmac.update('message');\n   * hmac.update(wordArray);\n   * ```\n   */\n  update(messageUpdate: WordArray | string): this {\n    this._hasher.update(messageUpdate);\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   * \n   * @param messageUpdate - An optional final message update\n   * @returns The computed HMAC\n   * @example\n   * ```javascript\n   * const hmacValue = hmac.finalize();\n   * const hmacValue = hmac.finalize('message');\n   * const hmacValue = hmac.finalize(wordArray);\n   * ```\n   */\n  finalize(messageUpdate?: WordArray | string): WordArray {\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n\n/**\n * Configuration options for key derivation functions\n */\nexport interface KDFCfg {\n  /** Key size for EvpKDF */\n  keySize?: number;\n  /** Hasher function for EvpKDF */\n  hasher?: new (cfg?: HasherCfg) => Hasher;\n  /** Number of iterations */\n  iterations?: number;\n}\n\n/**\n * Type definition for key derivation functions\n */\nexport type KDFFn = (password: WordArray | string, salt: WordArray | string, cfg?: KDFCfg) => WordArray;"],"mappings":"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"}