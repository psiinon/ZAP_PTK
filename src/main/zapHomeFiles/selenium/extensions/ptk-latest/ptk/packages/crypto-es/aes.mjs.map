{"version":3,"file":"aes.mjs","names":["_SBOX: number[]","INV_SBOX: number[]","_SUB_MIX_0: number[]","_SUB_MIX_1: number[]","_SUB_MIX_2: number[]","_SUB_MIX_3: number[]","INV_SUB_MIX_0: number[]","INV_SUB_MIX_1: number[]","INV_SUB_MIX_2: number[]","INV_SUB_MIX_3: number[]","d: number[]","t: number","t0","t1","t2","t3","AES: CipherObj"],"sources":["../src/aes.ts"],"sourcesContent":["import {\n  BlockCipher,\n  CipherObj,\n  WordArray,\n} from './cipher-core';\n\n// Lookup tables\nconst _SBOX: number[] = [];\nconst INV_SBOX: number[] = [];\nconst _SUB_MIX_0: number[] = [];\nconst _SUB_MIX_1: number[] = [];\nconst _SUB_MIX_2: number[] = [];\nconst _SUB_MIX_3: number[] = [];\nconst INV_SUB_MIX_0: number[] = [];\nconst INV_SUB_MIX_1: number[] = [];\nconst INV_SUB_MIX_2: number[] = [];\nconst INV_SUB_MIX_3: number[] = [];\n\n// Compute lookup tables\n(() => {\n  // Compute double table\n  const d: number[] = [];\n  for (let i = 0; i < 256; i += 1) {\n    if (i < 128) {\n      d[i] = i << 1;\n    } else {\n      d[i] = (i << 1) ^ 0x11b;\n    }\n  }\n\n  // Walk GF(2^8)\n  let x = 0;\n  let xi = 0;\n  for (let i = 0; i < 256; i += 1) {\n    // Compute sbox\n    let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n    _SBOX[x] = sx;\n    INV_SBOX[sx] = x;\n\n    // Compute multiplication\n    const x2 = d[x];\n    const x4 = d[x2];\n    const x8 = d[x4];\n\n    // Compute sub bytes, mix columns tables\n    let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n    _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n    _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n    _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n    _SUB_MIX_3[x] = t;\n\n    // Compute inv sub bytes, inv mix columns tables\n    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n    INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n    INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n    INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n    INV_SUB_MIX_3[sx] = t;\n\n    // Compute next counter\n    if (!x) {\n      xi = 1;\n      x = xi;\n    } else {\n      x = x2 ^ d[d[d[x8 ^ x2]]];\n      xi ^= d[d[xi]];\n    }\n  }\n})();\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nexport class AESAlgo extends BlockCipher {\n  /** Number of rounds for this key size */\n  private _nRounds!: number;\n  \n  /** Previous key for optimization */\n  private _keyPriorReset?: WordArray;\n  \n  /** Key schedule for encryption */\n  private _keySchedule!: number[];\n  \n  /** Inverse key schedule for decryption */\n  private _invKeySchedule!: number[];\n\n  /** Key size in 32-bit words */\n  static keySize = 256 / 32;\n\n  protected _doReset(): void {\n    let t: number;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M: number[], offset: number): void {\n    this._doCryptBlock(\n      M, offset, this._keySchedule!, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M: number[], offset: number): void {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule!,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  private _doCryptBlock(\n    M: number[],\n    offset: number,\n    keySchedule: number[],\n    SUB_MIX_0: number[],\n    SUB_MIX_1: number[],\n    SUB_MIX_2: number[],\n    SUB_MIX_3: number[],\n    SBOX: number[]\n  ): void {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds!;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = AES.encrypt(message, key, cfg);\n *     var plaintext  = AES.decrypt(ciphertext, key, cfg);\n */\nexport const AES: CipherObj = BlockCipher._createHelper(AESAlgo);"],"mappings":"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"}