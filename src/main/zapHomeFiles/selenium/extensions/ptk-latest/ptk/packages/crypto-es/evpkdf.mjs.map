{"version":3,"file":"evpkdf.mjs","names":["block: WordArray | undefined"],"sources":["../src/evpkdf.ts"],"sourcesContent":["import {\n  Base,\n  WordArray,\n} from './core';\nimport { MD5Algo } from './md5';\n\ninterface EvpKDFCfg {\n  keySize?: number;\n  hasher?: typeof MD5Algo;\n  iterations?: number;\n}\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nexport class EvpKDFAlgo extends Base {\n  cfg: EvpKDFCfg;\n\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = new EvpKDFAlgo();\n   *     const kdf = new EvpKDFAlgo({ keySize: 8 });\n   *     const kdf = new EvpKDFAlgo({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg?: EvpKDFCfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      {},\n      {\n        keySize: 128 / 32,\n        hasher: MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password: WordArray | string, salt: WordArray | string): WordArray {\n    let block: WordArray | undefined;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = new cfg.hasher!();\n\n    // Initial values\n    const derivedKey = WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize!) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations!; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize! * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = EvpKDF(password, salt);\n *     var key = EvpKDF(password, salt, { keySize: 8 });\n *     var key = EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const EvpKDF = (password: WordArray | string, salt: WordArray | string, cfg?: EvpKDFCfg): WordArray => new EvpKDFAlgo(cfg).compute(password, salt);"],"mappings":";;;;;;;;AAgBA,IAAa,aAAb,cAAgC,KAAK;CACnC;;;;;;;;;;;;CAaA,YAAY,KAAiB;AAC3B;;;;;;;;AASA,OAAK,MAAM,OAAO,OAChB,EAAE,EACF;GACE,SAAS,MAAM;GACf,QAAQ;GACR,YAAY;GACb,EACD;CAEH;;;;;;;;;;;;;CAcD,QAAQ,UAA8B,MAAqC;EACzE,IAAIA;EAGJ,MAAM,EAAE,KAAK,GAAG;EAGhB,MAAM,SAAS,IAAI,IAAI;EAGvB,MAAM,aAAa,UAAU;EAG7B,MAAM,kBAAkB,WAAW;EACnC,MAAM,EAAE,SAAS,YAAY,GAAG;AAGhC,SAAO,gBAAgB,SAAS,SAAU;AACxC,OAAI,MACF,QAAO,OAAO;AAEhB,WAAQ,OAAO,OAAO,UAAU,SAAS;AACzC,UAAO;AAGP,QAAK,IAAI,IAAI,GAAG,IAAI,YAAa,KAAK,GAAG;AACvC,YAAQ,OAAO,SAAS;AACxB,WAAO;GACR;AAED,cAAW,OAAO;EACnB;AACD,aAAW,WAAW,UAAW;AAEjC,SAAO;CACR;AACF;;;;;;;;;;;;;;;;;;AAmBD,MAAa,UAAU,UAA8B,MAA0B,QAA+B,IAAI,WAAW,KAAK,QAAQ,UAAU"}