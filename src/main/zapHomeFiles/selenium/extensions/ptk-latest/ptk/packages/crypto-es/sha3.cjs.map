{"version":3,"file":"sha3.cjs","names":["RHO_OFFSETS: number[]","PI_INDEXES: number[]","ROUND_CONSTANTS: X64Word[]","X64Word","a: X64Word[]","Hasher32","lane","tMsw: number","tLsw: number","hashWords: number[]","WordArray","SHA3: HashFn","Hasher","HmacSHA3: HMACHashFn"],"sources":["../src/sha3.ts"],"sourcesContent":["import {\n  WordArray,\n  Hasher,\n  Hasher32,\n  HasherCfg,\n  HashFn,\n  HMACHashFn,\n} from './core';\nimport { X64Word } from './x64-core';\n\n// Configuration interface for SHA3\ninterface SHA3Config extends HasherCfg {\n  outputLength?: number;\n}\n\n// Constants tables\nconst RHO_OFFSETS: number[] = [];\nconst PI_INDEXES: number[] = [];\nconst ROUND_CONSTANTS: X64Word[] = [];\n\n// Compute Constants\n(() => {\n  // Compute rho offset constants\n  let _x = 1;\n  let _y = 0;\n  for (let t = 0; t < 24; t += 1) {\n    RHO_OFFSETS[_x + 5 * _y] = ((t + 1) * (t + 2) / 2) % 64;\n\n    const newX = _y % 5;\n    const newY = (2 * _x + 3 * _y) % 5;\n    _x = newX;\n    _y = newY;\n  }\n\n  // Compute pi index constants\n  for (let x = 0; x < 5; x += 1) {\n    for (let y = 0; y < 5; y += 1) {\n      PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n    }\n  }\n\n  // Compute round constants\n  let LFSR = 0x01;\n  for (let i = 0; i < 24; i += 1) {\n    let roundConstantMsw = 0;\n    let roundConstantLsw = 0;\n\n    for (let j = 0; j < 7; j += 1) {\n      if (LFSR & 0x01) {\n        const bitPosition = (1 << j) - 1;\n        if (bitPosition < 32) {\n          roundConstantLsw ^= 1 << bitPosition;\n        } else /* if (bitPosition >= 32) */ {\n          roundConstantMsw ^= 1 << (bitPosition - 32);\n        }\n      }\n\n      // Compute next LFSR\n      if (LFSR & 0x80) {\n        // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n        LFSR = (LFSR << 1) ^ 0x71;\n      } else {\n        LFSR <<= 1;\n      }\n    }\n\n    ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n  }\n})();\n\n// Reusable objects for temporary values\nconst T = (() => {\n  const a: X64Word[] = [];\n  for (let i = 0; i < 25; i += 1) {\n    a[i] = X64Word.create();\n  }\n  return a;\n})();\n\n/**\n * SHA-3 hash algorithm.\n */\nexport class SHA3Algo extends Hasher32 {\n  declare cfg: SHA3Config;\n  private _state: X64Word[] = [];\n\n  /**\n   * Initializes a newly created hasher.\n   *\n   * @param cfg - Configuration options.\n   * @property {number} outputLength - The desired number of bits in the output hash.\n   *   Only values permitted are: 224, 256, 384, 512.\n   *   Default: 512\n   */\n  constructor(cfg?: SHA3Config) {\n    super(Object.assign(\n      { outputLength: 512 },\n      cfg,\n    ));\n  }\n\n  _doReset(): void {\n    // Clear and reinitialize state array\n    this._state = [];\n    for (let i = 0; i < 25; i += 1) {\n      this._state[i] = new X64Word();\n    }\n\n    this.blockSize = (1600 - 2 * this.cfg.outputLength!) / 32;\n  }\n\n  _doProcessBlock(M: number[], offset: number): void {\n    // Ensure state is initialized\n    if (this._state.length === 0) {\n      this._doReset();\n    }\n    \n    // Shortcuts\n    const state = this._state;\n    const nBlockSizeLanes = this.blockSize / 2;\n\n    // Absorb\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\n      // Shortcuts\n      let M2i = M[offset + 2 * i];\n      let M2i1 = M[offset + 2 * i + 1];\n\n      // Swap endian\n      M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff)\n        | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);\n      M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff)\n        | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);\n\n      // Absorb message into state\n      const lane = state[i];\n      lane.high ^= M2i1;\n      lane.low ^= M2i;\n    }\n\n    // Rounds\n    for (let round = 0; round < 24; round += 1) {\n      // Theta\n      for (let x = 0; x < 5; x += 1) {\n        // Mix column lanes\n        let tMsw = 0;\n        let tLsw = 0;\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          tMsw ^= lane.high;\n          tLsw ^= lane.low;\n        }\n\n        // Temporary values\n        const Tx = T[x];\n        Tx.high = tMsw;\n        Tx.low = tLsw;\n      }\n      for (let x = 0; x < 5; x += 1) {\n        // Shortcuts\n        const Tx4 = T[(x + 4) % 5];\n        const Tx1 = T[(x + 1) % 5];\n        const Tx1Msw = Tx1.high;\n        const Tx1Lsw = Tx1.low;\n\n        // Mix surrounding columns\n        const tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n        const tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          lane.high ^= tMsw;\n          lane.low ^= tLsw;\n        }\n      }\n\n      // Rho Pi\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n        let tMsw: number;\n        let tLsw: number;\n\n        // Shortcuts\n        const lane = state[laneIndex];\n        const laneMsw = lane.high;\n        const laneLsw = lane.low;\n        const rhoOffset = RHO_OFFSETS[laneIndex];\n\n        // Rotate lanes\n        if (rhoOffset < 32) {\n          tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n          tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n        } else /* if (rhoOffset >= 32) */ {\n          tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n          tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n        }\n\n        // Transpose lanes\n        const TPiLane = T[PI_INDEXES[laneIndex]];\n        TPiLane.high = tMsw;\n        TPiLane.low = tLsw;\n      }\n\n      // Rho pi at x = y = 0\n      const T0 = T[0];\n      const state0 = state[0];\n      T0.high = state0.high;\n      T0.low = state0.low;\n\n      // Chi\n      for (let x = 0; x < 5; x += 1) {\n        for (let y = 0; y < 5; y += 1) {\n          // Shortcuts\n          const laneIndex = x + 5 * y;\n          const lane = state[laneIndex];\n          const TLane = T[laneIndex];\n          const Tx1Lane = T[((x + 1) % 5) + 5 * y];\n          const Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n          // Mix rows\n          lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n          lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\n        }\n      }\n\n      // Iota\n      const lane = state[0];\n      const roundConstant = ROUND_CONSTANTS[round];\n      lane.high ^= roundConstant.high;\n      lane.low ^= roundConstant.low;\n    }\n  }\n\n  _doFinalize(): WordArray {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsLeft = data.sigBytes * 8;\n    const blockSizeBits = this.blockSize * 32;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - (nBitsLeft % 32));\n    dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const state = this._state;\n    const outputLengthBytes = this.cfg.outputLength! / 8;\n    const outputLengthLanes = outputLengthBytes / 8;\n\n    // Squeeze\n    const hashWords: number[] = [];\n    for (let i = 0; i < outputLengthLanes; i += 1) {\n      // Shortcuts\n      const lane = state[i];\n      let laneMsw = lane.high;\n      let laneLsw = lane.low;\n\n      // Swap endian\n      laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff)\n        | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);\n      laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff)\n        | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);\n\n      // Squeeze state to retrieve hash\n      hashWords.push(laneLsw);\n      hashWords.push(laneMsw);\n    }\n\n    // Return final computed hash\n    return new WordArray(hashWords, outputLengthBytes);\n  }\n\n  clone(): this {\n    const clone = super.clone.call(this);\n\n    // Clone the state array\n    clone._state = [];\n    for (let i = 0; i < this._state.length; i += 1) {\n      clone._state[i] = this._state[i].clone();\n    }\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param message - The message to hash.\n * @returns The hash.\n *\n * @example\n * ```js\n * const hash = SHA3('message');\n * const hash = SHA3(wordArray);\n * ```\n */\nexport const SHA3: HashFn = Hasher._createHelper(SHA3Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param message - The message to hash.\n * @param key - The secret key.\n * @returns The HMAC.\n *\n * @example\n * ```js\n * const hmac = HmacSHA3(message, key);\n * ```\n */\nexport const HmacSHA3: HMACHashFn = Hasher._createHmacHelper(SHA3Algo);"],"mappings":"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"}