{"version":3,"file":"mode-ofb.mjs","names":[],"sources":["../src/mode-ofb.ts"],"sourcesContent":["import {\n  BlockCipherMode,\n} from './cipher-core';\n\n/**\n * OFB Encryptor/Decryptor (same operation)\n */\nclass OFBMode extends BlockCipherMode {\n  /** Keystream for OFB mode */\n  _keystream?: number[];\n\n  processBlock(words: number[], offset: number): void {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const blockSize = cipher.blockSize!;\n    const iv = this._iv;\n    let keystream = this._keystream;\n\n    // Generate keystream\n    if (iv) {\n      this._keystream = iv.slice(0);\n      keystream = this._keystream;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    } else if (!keystream) {\n      // If no IV and no existing keystream, initialize with zeros\n      this._keystream = new Array(blockSize).fill(0);\n      keystream = this._keystream;\n    }\n    cipher.encryptBlock!(keystream!, 0);\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream![i];\n    }\n  }\n}\n\n/**\n * Output Feedback block mode.\n */\nexport class OFB extends BlockCipherMode {\n  /** Keystream for OFB mode */\n  _keystream?: number[];\n\n  static readonly Encryptor = OFBMode;\n  static readonly Decryptor = OFBMode;\n}"],"mappings":";;;;;;AAOA,IAAM,UAAN,cAAsB,gBAAgB;;CAEpC;CAEA,aAAa,OAAiB,QAAsB;EAClD,MAAM,SAAS;EAGf,MAAM,SAAS,KAAK;EACpB,MAAM,YAAY,OAAO;EACzB,MAAM,KAAK,KAAK;EAChB,IAAI,YAAY,KAAK;AAGrB,MAAI,IAAI;AACN,QAAK,aAAa,GAAG,MAAM;AAC3B,eAAY,KAAK;AAGjB,QAAK,MAAM;EACZ,WAAU,CAAC,WAAW;AAErB,QAAK,aAAa,IAAI,MAAM,WAAW,KAAK;AAC5C,eAAY,KAAK;EAClB;AACD,SAAO,aAAc,WAAY;AAGjC,OAAK,IAAI,IAAI,GAAG,IAAI,WAAW,KAAK,EAClC,QAAO,SAAS,MAAM,UAAW;CAEpC;AACF;;;;AAKD,IAAa,MAAb,cAAyB,gBAAgB;;CAEvC;CAEA,OAAgB,YAAY;CAC5B,OAAgB,YAAY;AAC7B"}